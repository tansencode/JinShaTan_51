C51 COMPILER V9.01   MAIN                                                                  05/06/2018 23:20:48 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          //#define  _LED_BUZZER_C
   3          #define _TIME_C
   4          sbit ADDR0 = P1^0;
   5          sbit ADDR1 = P1^1;
   6          sbit ADDR2 = P1^2;
   7          sbit ADDR3 = P1^3;
   8          sbit ENLED = P1^4;
   9          
  10          unsigned char code LedChar[] = {  //数码管显示字符转换表
  11              0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
  12              0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
  13          };
  14          unsigned char LedBuff[] = { //数码管显示缓冲区
  15          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
  16          };
  17          unsigned char LedBuff1[] = { //数码管显示缓冲区
  18          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
  19          };
  20          unsigned char Leddp[]={
  21          0x7F,0x7F,0x7F,0x7F,0x7F,0x7F};
  22          
  23          //struct sLedBuff ledBuff;
  24          struct sTime CurTime;
  25          struct sTime {  //日期时间结构体定义
  26              unsigned int  year;
  27              unsigned char mon;
  28              unsigned char day;
  29              unsigned char hour;
  30              unsigned char min;
  31              unsigned char sec;
  32              unsigned char week;
  33          };
  34          
  35          bit flag200ms = 1;  //200ms定时标志
  36          struct sTime bufTime;  //日期时间缓冲区
  37          unsigned char setIndex = 0;  //时间设置索引
  38          unsigned char T0RH = 0;  //T0重载值的高字节
  39          unsigned char T0RL = 0;  //T0重载值的低字节
  40          unsigned int index;
  41          unsigned int num;
  42          unsigned int point;
  43          
  44          void ConfigTimer0(unsigned int ms);
  45          void RefreshTimeShow();
  46          void RefreshTime();
  47          extern void InitDS1302();
  48          extern void GetRealTime(struct sTime *time);
  49          extern void SetRealTime(struct sTime *time);
  50          extern void KeyScan();
  51          extern void KeyDriver();
  52          extern void InitLcd1602();
  53          extern void LcdShowStr(unsigned char x, unsigned char y, unsigned char *str);
  54          extern void LcdSetCursor(unsigned char x, unsigned char y);
  55          extern void LcdOpenCursor();
C51 COMPILER V9.01   MAIN                                                                  05/06/2018 23:20:48 PAGE 2   

  56          extern void LcdCloseCursor();
  57          
  58          
  59          /* 数码管上显示一位数字，index-数码管位索引(从右到左对应0～5)，
  60          **     num-待显示的数字，point-代表是否显示此位上的小数点 */
  61          void ShowLedNumber(unsigned int index, unsigned int num,unsigned int point)
  62          {
  63   1         unsigned char buf[6];
  64   1         P0=0xFF;
  65   1         LedBuff[index] = LedChar[num];  //输入数字转换为数码管字符0～F
  66   1          if (point != 0)
  67   1          {
  68   2             LedBuff[index] &= 0x7F;  //point不为0时点亮当前位的小数点
  69   2          }
  70   1      }
*** WARNING C280 IN LINE 63 OF MAIN.C: 'buf': unreferenced local variable
  71          
  72          void main()
  73          {
  74   1          unsigned char psec=0xAA;  //秒备份，初值AA确保首次读取时间后会刷新显示
  75   1          EA = 1;           //开总中断
  76   1              ENLED = 0; //选择数码管进行显示
  77   1          ADDR3 = 1;
  78   1              ET0 = 1; //使能 T0 中断
  79   1              TR0 = 1; //启动 T0
  80   1          ConfigTimer0(1);  //T0定时1ms
  81   1              P0=0xFF;
  82   1          InitDS1302();     //初始化实时时钟
  83   1          InitLcd1602();    //初始化液晶
  84   1               RefreshTime();
  85   1          
  86   1          //初始化屏幕上固定不变的内容
  87   1          LcdShowStr(3, 0, "20  -  -  ");
  88   1              LcdShowStr(4,1," : : ");
  89   1          
  90   1          while (1)
  91   1          {
  92   2              KeyDriver();  //调用按键驱动
  93   2              if (flag200ms && (setIndex == 0))
  94   2              {                             //每隔200ms且未处于设置状态时，
  95   3                  flag200ms = 0;
  96   3                              
  97   3                              RefreshTime();
  98   3                              P0=0xFF;
  99   3                  GetRealTime(&bufTime);    //获取当前时间
 100   3                  if (psec != bufTime.sec)  //检测到时间有变化时刷新显示
 101   3                  {
 102   4                      RefreshTimeShow();
 103   4                      psec = bufTime.sec;   //用当前值更新上次秒数
 104   4                                      RefreshTime();
 105   4                  }
 106   3              }
 107   2          }
 108   1      }
 109          
 110          /* 将一个BCD码字节显示到屏幕上，(x,y)-屏幕起始坐标，bcd-待显示BCD码 */
 111          void ShowBcdByte(unsigned char x, unsigned char y, unsigned char bcd)
 112          {
 113   1          unsigned char str[4];
 114   1          
 115   1          str[0] = (bcd >> 4) + '0';
 116   1          str[1] = (bcd&0x0F) + '0';
C51 COMPILER V9.01   MAIN                                                                  05/06/2018 23:20:48 PAGE 3   

 117   1          str[2] = '\0';
 118   1          LcdShowStr(x, y, str);
 119   1          ShowLedNumber(index,num,point);
 120   1      
 121   1      }
 122          
 123          /* 获取当前日期时间，并刷新时间和星期的显示 */
 124          void RefreshTime()
 125          {
 126   1          GetRealTime(&bufTime);                  //获取当前日期时间
 127   1          ShowLedNumber(5,bufTime.hour>>4, 0);   //时
 128   1          ShowLedNumber(4, bufTime.hour&0xF,0);
 129   1          ShowLedNumber(3, bufTime.min>>4,  0);   //分
 130   1          ShowLedNumber(2, bufTime.min&0xF, 0);
 131   1          ShowLedNumber(1, bufTime.sec>>4,  0);   //秒
 132   1          ShowLedNumber(0, bufTime.sec&0xF, 0);
 133   1      } 
 134          /* 日期刷新函数，ops-刷新选项：为0时只当日期变化才刷新，非0则立即刷新 */
 135          /*void RefreshDate(uint8 ops)
 136          {
 137              uint8 pdata str[12];
 138              static uint8 backup = 0;
 139              
 140              if ((backup!=CurTime.day) || (ops!=0))
 141              {
 142                  str[0] = ((CurTime.year>>12) & 0xF) + '0';  //4位数年份
 143                  str[1] = ((CurTime.year>>8) & 0xF) + '0';
 144                  str[2] = ((CurTime.year>>4) & 0xF) + '0';
 145                  str[3] = (CurTime.year & 0xF) + '0';
 146                  str[4] = '-';                        //分隔符
 147                  str[5] = (CurTime.mon >> 4) + '0';   //月份
 148                  str[6] = (CurTime.mon & 0xF) + '0';
 149                  str[7] = '-';                        //分隔符
 150                  str[8] = (CurTime.day >> 4) + '0';   //日期
 151                  str[9] = (CurTime.day & 0xF) + '0';
 152                  str[10] = '\0';         //字符串结束符
 153                  LcdShowStr(0, 0, str);  //显示到液晶上
 154                  backup = CurTime.day;   //刷新上次日期值
 155              }
 156          } */
 157          /* 刷新日期时间的显示 */
 158          void RefreshTimeShow()
 159          {
 160   1          ShowBcdByte(5,  0, bufTime.year);
 161   1          ShowBcdByte(8,  0, bufTime.mon);
 162   1          ShowBcdByte(11, 0, bufTime.day);
 163   1          ShowBcdByte(4,  1, bufTime.hour);
 164   1          ShowBcdByte(7,  1, bufTime.min);
 165   1          ShowBcdByte(10, 1, bufTime.sec);
 166   1      }
 167             
 168          
 169          /* 数码管动态扫描刷新函数，需在定时中断中调用 */
 170          void LedScan()
 171          {
 172   1         static unsigned char i = 0; //动态扫描的索引
 173   1         P0 = 0xFF; //显示消隐
 174   1         P1=(P1&0xF8)|i;               //重点，P1口低三位是定义ADDR0~R2的，进行位选
 175   1         P0=LedBuff[i];
 176   1         if(i<5)
 177   1           i++;
 178   1         else
C51 COMPILER V9.01   MAIN                                                                  05/06/2018 23:20:48 PAGE 4   

 179   1           i=0;
 180   1      }
 181          
 182          
 183          /* 刷新当前设置位的光标指示 */
 184          void RefreshSetShow()
 185          {
 186   1          switch (setIndex)
 187   1          {
 188   2              case 1:  LcdSetCursor(5,  0); break;
 189   2              case 2:  LcdSetCursor(6,  0); break;
 190   2              case 3:  LcdSetCursor(8,  0); break;
 191   2              case 4:  LcdSetCursor(9,  0); break;
 192   2              case 5:  LcdSetCursor(11, 0); break;
 193   2              case 6:  LcdSetCursor(12, 0); break;
 194   2              case 7:  LcdSetCursor(4,  1); break;
 195   2              case 8:  LcdSetCursor(5,  1); break;
 196   2                      case 9:  LcdSetCursor(7,  1); break;
 197   2                      case 10: LcdSetCursor(8,  1); break;
 198   2                      case 11: LcdSetCursor(10,  1); break;
 199   2                      case 12: LcdSetCursor(11,  1); break;
 200   2              default:  break;
 201   2          }
 202   1      }
 203          /* 递增一个BCD码的高位 */
 204          unsigned char IncBcdHigh(unsigned char bcd)
 205          {
 206   1          if ((bcd&0xF0) < 0x90)
 207   1              bcd += 0x10;
 208   1          else
 209   1              bcd &= 0x0F;
 210   1          
 211   1          return bcd;
 212   1      }
 213          /* 递增一个BCD码的低位 */
 214          unsigned char IncBcdLow(unsigned char bcd)
 215          {
 216   1          if ((bcd&0x0F) < 0x09)
 217   1              bcd += 0x01;
 218   1          else
 219   1              bcd &= 0xF0;
 220   1          
 221   1          return bcd;
 222   1      }
 223          /* 递减一个BCD码的高位 */
 224          unsigned char DecBcdHigh(unsigned char bcd)
 225          {
 226   1          if ((bcd&0xF0) > 0x00)
 227   1              bcd -= 0x10;
 228   1          else
 229   1              bcd |= 0x90;
 230   1          
 231   1          return bcd;
 232   1      }
 233          /* 递减一个BCD码的低位 */
 234          unsigned char DecBcdLow(unsigned char bcd)
 235          {
 236   1          if ((bcd&0x0F) > 0x00)
 237   1              bcd -= 0x01;
 238   1          else
 239   1              bcd |= 0x09;
 240   1          
C51 COMPILER V9.01   MAIN                                                                  05/06/2018 23:20:48 PAGE 5   

 241   1          return bcd;
 242   1      }
 243          /* 递增时间当前设置位的值 */
 244          void IncSetTime()
 245          {
 246   1          switch (setIndex)
 247   1          {
 248   2              case 1:  bufTime.year = IncBcdHigh(bufTime.year); break;
 249   2              case 2:  bufTime.year = IncBcdLow(bufTime.year);  break;
 250   2              case 3:  bufTime.mon  = IncBcdHigh(bufTime.mon);  break;
 251   2              case 4:  bufTime.mon  = IncBcdLow(bufTime.mon);   break;
 252   2              case 5:  bufTime.day  = IncBcdHigh(bufTime.day);  break;
 253   2              case 6:  bufTime.day  = IncBcdLow(bufTime.day);   break;
 254   2              case 7:  bufTime.hour = IncBcdHigh(bufTime.hour); break;
 255   2              case 8:  bufTime.hour = IncBcdLow(bufTime.hour);  break;
 256   2              case 9:  bufTime.min  = IncBcdHigh(bufTime.min);  break;
 257   2              case 10: bufTime.min  = IncBcdLow(bufTime.min);   break;
 258   2              case 11: bufTime.sec  = IncBcdHigh(bufTime.sec);  break;
 259   2              case 12: bufTime.sec  = IncBcdLow(bufTime.sec);   break;
 260   2              default:  break;
 261   2          }
 262   1          RefreshTimeShow();
 263   1          RefreshSetShow();
 264   1      }
 265          /* 递减时间当前设置位的值 */
 266          void DecSetTime()
 267          {
 268   1          switch (setIndex)
 269   1          {
 270   2              case 1:  bufTime.year = DecBcdHigh(bufTime.year); break;
 271   2              case 2:  bufTime.year = DecBcdLow(bufTime.year);  break;
 272   2              case 3:  bufTime.mon  = DecBcdHigh(bufTime.mon);  break;
 273   2              case 4:  bufTime.mon  = DecBcdLow(bufTime.mon);   break;
 274   2              case 5:  bufTime.day  = DecBcdHigh(bufTime.day);  break;
 275   2              case 6:  bufTime.day  = DecBcdLow(bufTime.day);   break;
 276   2              case 7:  bufTime.hour = DecBcdHigh(bufTime.hour); break;
 277   2              case 8:  bufTime.hour = DecBcdLow(bufTime.hour);  break;
 278   2              case 9:  bufTime.min  = DecBcdHigh(bufTime.min);  break;
 279   2              case 10: bufTime.min  = DecBcdLow(bufTime.min);   break;
 280   2              case 11: bufTime.sec  = DecBcdHigh(bufTime.sec);  break;
 281   2              case 12: bufTime.sec  = DecBcdLow(bufTime.sec);   break;
 282   2              default:  break;
 283   2          }
 284   1          RefreshTimeShow();
 285   1          RefreshSetShow();
 286   1      }
 287          /* 右移时间设置位 */
 288          void RightShiftTimeSet()
 289          {
 290   1          if (setIndex != 0)
 291   1          {
 292   2              if (setIndex < 12)
 293   2                  setIndex++;
 294   2              else
 295   2                  setIndex = 1;
 296   2              RefreshSetShow();
 297   2          }
 298   1      }
 299          /* 左移时间设置位 */
 300          void LeftShiftTimeSet()
 301          {
 302   1          if (setIndex != 0)
C51 COMPILER V9.01   MAIN                                                                  05/06/2018 23:20:48 PAGE 6   

 303   1          {
 304   2              if (setIndex > 1)
 305   2                  setIndex--;
 306   2              else
 307   2                  setIndex = 12;
 308   2              RefreshSetShow();
 309   2          }
 310   1      }
 311          /* 进入时间设置状态 */
 312          void EnterTimeSet()
 313          {
 314   1          static unsigned char i = 5; //动态扫描的索引
 315   1          setIndex = 2;       //把设置索引设置为2，即可进入设置状态
 316   1          LeftShiftTimeSet(); //再利用现成的左移操作移到位置1并完成显示刷新
 317   1          LcdOpenCursor();    //打开光标闪烁效果
 318   1      }
*** WARNING C280 IN LINE 314 OF MAIN.C: 'i': unreferenced local variable
 319          /* 退出时间设置状态，save-是否保存当前设置的时间值 */
 320          void ExitTimeSet(bit save)
 321          {
 322   1          setIndex = 0;     //把设置索引设置为0，即可退出设置状态
 323   1          if (save)         //需保存时即把当前设置时间写入DS1302
 324   1          {
 325   2              SetRealTime(&bufTime);
 326   2          }
 327   1          LcdCloseCursor(); //关闭光标显示
 328   1      }
 329          /* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 */
 330          void KeyAction(unsigned char keycode)
 331          {
 332   1          static unsigned char i = 0; //动态扫描的索引
 333   1          if  ((keycode>='0') && (keycode<='9'))  //本例中不响应字符键
 334   1          {
 335   2          }
 336   1          else if (keycode == 0x26)  //向上键，递增当前设置位的值
 337   1          {
 338   2              IncSetTime();
 339   2          }
 340   1          else if (keycode == 0x28)  //向下键，递减当前设置位的值
 341   1          {
 342   2              DecSetTime();
 343   2          }
 344   1          else if (keycode == 0x25)  //向左键，向左切换设置位
 345   1          {
 346   2              LeftShiftTimeSet();
 347   2          }
 348   1          else if (keycode == 0x27)  //向右键，向右切换设置位
 349   1          {
 350   2                  
 351   2              RightShiftTimeSet();
 352   2          }
 353   1          else if (keycode == 0x0D)  //回车键，进入设置模式/启用当前设置值
 354   1          {
 355   2              if (setIndex == 0)  //不处于设置状态时，进入设置状态
 356   2              {
 357   3                  EnterTimeSet();
 358   3              }
 359   2              else                //已处于设置状态时，保存时间并退出设置状态
 360   2              {
 361   3                  ExitTimeSet(1);
 362   3              }
 363   2          }
C51 COMPILER V9.01   MAIN                                                                  05/06/2018 23:20:48 PAGE 7   

 364   1          else if (keycode == 0x1B)  //Esc键，取消当前设置
 365   1          {
 366   2              ExitTimeSet(0);
 367   2          }
 368   1      }
*** WARNING C280 IN LINE 332 OF MAIN.C: 'i': unreferenced local variable
 369          /* 配置并启动T0，ms-T0定时时间 */
 370          void ConfigTimer0(unsigned int ms)
 371          {
 372   1          unsigned long tmp;  //临时变量
 373   1          
 374   1          tmp = 11059200 / 12;      //定时器计数频率
 375   1          tmp = (tmp * ms) / 1000;  //计算所需的计数值
 376   1          tmp = 65536 - tmp;        //计算定时器重载值
 377   1          tmp = tmp + 28;           //补偿中断响应延时造成的误差
 378   1          T0RH = (unsigned char)(tmp>>8);  //定时器重载值拆分为高低字节
 379   1          T0RL = (unsigned char)tmp;
 380   1          TMOD &= 0xF0;   //清零T0的控制位
 381   1          TMOD |= 0x01;   //配置T0为模式1
 382   1          TH0 = T0RH;     //加载T0重载值
 383   1          TL0 = T0RL;
 384   1          ET0 = 1;        //使能T0中断
 385   1          TR0 = 1;        //启动T0
 386   1      }
 387          /* T0中断服务函数，执行按键扫描和200ms定时 */
 388          void InterruptTimer0() interrupt 1
 389          {
 390   1          static unsigned char tmr200ms = 0;
 391   1              static int i=0;
 392   1      
 393   1          TH0 = T0RH;  //重新加载重载值
 394   1          TL0 = T0RL;
 395   1      /*      if(ENLED==0)
 396   1              {
 397   1                P0=0xff;
 398   1                P1=(P1&0xF0)|i;
 399   1                P0=*((int data*)&LedBuff+i);
 400   1                if(i<(sizeof(LedBuff)-1))
 401   1                i++;
 402   1                else
 403   1                i=0;
 404   1              }
 405   1              */
 406   1              LedScan(); //调用数码管显示扫描函数
 407   1          tmr200ms++;
 408   1          if (tmr200ms >= 200)  //定时200ms
 409   1          {
 410   2              tmr200ms = 0;
 411   2              flag200ms = 1;
 412   2          }
 413   1              KeyScan();   //按键扫描
 414   1      }
*** WARNING C280 IN LINE 391 OF MAIN.C: 'i': unreferenced local variable
 415          
 416          /* T2中断服务函数，LED动态扫描、蜂鸣器控制 */
 417          /*void InterruptTimer2() interrupt 5
 418          {
 419              static i = 0;  //LED位选索引
 420              
 421              TF2 = 0;  //清零T2中断标志
 422              //全部LED动态扫描显示
 423              if (ENLED == 0)  //LED使能时才进行动态扫描
C51 COMPILER V9.01   MAIN                                                                  05/06/2018 23:20:48 PAGE 8   

 424              {
 425                  P0 = 0xFF;                       //关闭所有段选位，显示消隐
 426                  P1 = (P1 & 0xF0) | i;            //位选索引值赋值到P1口低4位
 427                  P0 = *((data*)&ledBuff+i); //缓冲区中索引位置的数据送到P0口
 428                  if (i < (sizeof(ledBuff)-1))     //索引递增循环，遍历整个缓冲区
 429                      i++;
 430                  else
 431                      i = 0;
 432              }
 433          }  */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1233    ----
   CONSTANT SIZE    =     33    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
